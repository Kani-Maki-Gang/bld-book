<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Bld book</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="getting_started.html"><strong aria-hidden="true">1.</strong> Getting started</a></li><li class="chapter-item expanded "><a href="pipelines/preface.html"><strong aria-hidden="true">2.</strong> Pipelines</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="pipelines/version2.html"><strong aria-hidden="true">2.1.</strong> Version 2</a></li><li class="chapter-item expanded "><a href="pipelines/version1.html"><strong aria-hidden="true">2.2.</strong> Version 1</a></li></ol></li><li class="chapter-item expanded "><a href="configuration/preface.html"><strong aria-hidden="true">3.</strong> Configuration</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="server/preface.html"><strong aria-hidden="true">3.1.</strong> Server mode</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="configuration/server/running_a_server.html"><strong aria-hidden="true">3.1.1.</strong> Running a server</a></li><li class="chapter-item expanded "><a href="configuration/server/authorization.html"><strong aria-hidden="true">3.1.2.</strong> Authorization</a></li><li class="chapter-item expanded "><a href="configuration/server/tls.html"><strong aria-hidden="true">3.1.3.</strong> TLS</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="cli/preface.html"><strong aria-hidden="true">4.</strong> Command line interface</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cli/cat.html"><strong aria-hidden="true">4.1.</strong> Cat</a></li><li class="chapter-item expanded "><a href="cli/check.html"><strong aria-hidden="true">4.2.</strong> Check</a></li><li class="chapter-item expanded "><a href="cli/config.html"><strong aria-hidden="true">4.3.</strong> Config</a></li><li class="chapter-item expanded "><a href="cli/cron.html"><strong aria-hidden="true">4.4.</strong> Cron</a></li><li class="chapter-item expanded "><a href="cli/help.html"><strong aria-hidden="true">4.5.</strong> Help</a></li><li class="chapter-item expanded "><a href="cli/hist.html"><strong aria-hidden="true">4.6.</strong> Hist</a></li><li class="chapter-item expanded "><a href="cli/init.html"><strong aria-hidden="true">4.7.</strong> Init</a></li><li class="chapter-item expanded "><a href="cli/login.html"><strong aria-hidden="true">4.8.</strong> Login</a></li><li class="chapter-item expanded "><a href="cli/ls.html"><strong aria-hidden="true">4.9.</strong> Ls</a></li><li class="chapter-item expanded "><a href="cli/monit.html"><strong aria-hidden="true">4.10.</strong> Monit</a></li><li class="chapter-item expanded "><a href="cli/pull.html"><strong aria-hidden="true">4.11.</strong> Pull</a></li><li class="chapter-item expanded "><a href="cli/push.html"><strong aria-hidden="true">4.12.</strong> Push</a></li><li class="chapter-item expanded "><a href="cli/rm.html"><strong aria-hidden="true">4.13.</strong> Rm</a></li><li class="chapter-item expanded "><a href="cli/run.html"><strong aria-hidden="true">4.14.</strong> Run</a></li><li class="chapter-item expanded "><a href="cli/server.html"><strong aria-hidden="true">4.15.</strong> Server</a></li><li class="chapter-item expanded "><a href="cli/stop.html"><strong aria-hidden="true">4.16.</strong> Stop</a></li><li class="chapter-item expanded "><a href="cli/supervisor.html"><strong aria-hidden="true">4.17.</strong> Supervisor</a></li><li class="chapter-item expanded "><a href="cli/worker.html"><strong aria-hidden="true">4.18.</strong> Worker</a></li></ol></li><li class="chapter-item expanded "><a href="examples/preface.html"><strong aria-hidden="true">5.</strong> Examples</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="examples/dotnet-pipeline.html"><strong aria-hidden="true">5.1.</strong> .NET pipeline</a></li><li class="chapter-item expanded "><a href="examples/nodejs-pipeline.html"><strong aria-hidden="true">5.2.</strong> Nodejs pipeline</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Bld book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p align="center">
    <img style="text-align: center;" height="200" width="200" src="./assets/logo.png">
</p>
<h1 id="what-is-bld"><a class="header" href="#what-is-bld">What is Bld</a></h1>
<p>Bld is a CI/CD tool that targets to build pipelines both in a local environment and in a server.</p>
<h1 id="building"><a class="header" href="#building">Building</a></h1>
<p>Bld is built using the Rust programming language so you will need a <a href="https://www.rust-lang.org/tools/install">Rust installation</a> in order to compile it.</p>
<h3 id="external-dependencies"><a class="header" href="#external-dependencies">External dependencies</a></h3>
<p>Additionally the project requires some external dependencies:</p>
<ul>
<li>build-essential</li>
<li>pkg-config</li>
<li>libssl-dev</li>
<li>libsqlite3-dev</li>
<li>(optional) docker</li>
</ul>
<blockquote>
<p>The package names are for Debian based distributions, install the appropriate packages on your distribution of choice.</p>
</blockquote>
<h3 id="build-instructions"><a class="header" href="#build-instructions">Build instructions</a></h3>
<p>Once you have installed all of the above, you can build the project as follows</p>
<pre><code class="language-bash">$ git clone https://github.com/Kani-Maki-Gang/bld.git
$ cd bld
$ cargo build --release
$ ./target/release/bld --version
</code></pre>
<h3 id="musl-builds"><a class="header" href="#musl-builds">Musl builds</a></h3>
<p>Since there are multiple dependencies deployment of bld can be difficult, so the project supports targeting musl for static linking. If you have an existing bld binary locally built/installed then follow the below instructions. This steps require a docker installation.</p>
<pre><code class="language-bash">$ bld run -p build-musl.yaml
$ ls dist
</code></pre>
<p>Or you can use cargo to built bld for your system and then run the pipelines for the musl build</p>
<pre><code class="language-bash">$ cargo run -- run -p build-musl.yaml
$ ls dist
</code></pre>
<p>With the above a new container will be built with all the necessary dependencies for building the project and the bld pipeline will clone the repository, build the binary and the copy it in the musl/dist directory.</p>
<p>If a bld binary is not available, you will have to start a container with the bld-musl-builder and do the steps manually.</p>
<blockquote>
<p>The project currently targets only Linux. It has not been tested on Windows or Macos.</p>
</blockquote>
<h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>For a prebuilt version of bld go to the github <a href="https://github.com/Kani-Maki-Gang/bld/releases">releases</a> page and download the latest version.</p>
<h1 id="creating-a-project"><a class="header" href="#creating-a-project">Creating a project</a></h1>
<p>If you have followed the above Building section and have a Bld binary available, you can execute the below commands to initialize a Bld directory.</p>
<pre><code class="language-bash">$ bld init
</code></pre>
<p>This will create a <code>.bld</code> directory with 2 files</p>
<ul>
<li><code>config.yaml</code> Which contains the configuration for the current directory</li>
<li><code>default.yaml</code> The default pipeline which simply echos a 'hello world'</li>
</ul>
<p>To test out the default pipeline simply execute</p>
<pre><code class="language-bash">$ bld run -p default.yaml
</code></pre>
<p>The pipeline will execute on your machine, but it can be changed to target a docker container. Below is the same default pipeline but having the <code>runs-on</code> section changed to target an <code>ubuntu</code> docker image, just make sure it is installed.</p>
<pre><code class="language-yaml">runs_on: ubuntu
version: 2
jobs:
  main:
  - echo 'hello world'
</code></pre>
<h1 id="creating-pipelines"><a class="header" href="#creating-pipelines">Creating pipelines</a></h1>
<p>In order to make new pipelines, you just need to create a yaml file under the <code>.bld</code> directory. For better structure you can add pipelines in directories and give the relative path to bld.</p>
<p>For example given a sample project you might want to have a build and deploy pipelines, the structure could be done as</p>
<pre><code>.bld
 |    config.yaml
 |    default.yaml
 └─── sample
      |    build.yaml
      |    deploy.yaml
</code></pre>
<p>And the pipelines can be run with their relative path inside the <code>.bld</code> directory.</p>
<pre><code class="language-bash">$ bld run -p sample/build.yaml
$ bld run -p sample/deploy.yaml
</code></pre>
<h1 id="quick-pipeline-example"><a class="header" href="#quick-pipeline-example">Quick pipeline example</a></h1>
<p>If you want a quick example of how a more involed pipeline would look, lets take the below example that tries to build a .net project and also run static analysis that will be sent to a sonar qube instance.</p>
<p>This is the example pipeline that runs the scanner called <code>example-project/scanner.yaml</code></p>
<pre><code class="language-yaml">name: Example .net project sonar scanner pipeline
version: 2
runs_on:
  dockerfile: /path/to/custom-dockerfile-for-scanner
  tag: latest
  name: scanner

variables:
  branch: master
  key: ExampleProject
  url: http://some-url-for-sonar-qube
  login: some_login_token

jobs:
  main:
  - git clone ${{branch}} https://some-url-for-the-repository
  - working_dir: /example-project/src
    exec:
    - dotnet sonarscanner begin /k:&quot;${{key}}&quot; /d:sonar.host.url=${{url}} /d:sonar.login=&quot;${{login}}&quot;
    - dotnet build
    - dotnet sonarscanner end /d:sonar.login=&quot;${{login}}&quot;
</code></pre>
<p>This is the example pipeline that builds the release version of the project called <code>example-project/build.yaml</code></p>
<pre><code class="language-yaml">name: Example project build pipeline
version: 2
runs_on:
  image: mcr.microsoft.com/dotnet/sdk:6.0-focal
  pull: true

variables:
  branch: master
  config: release

artifacts:
- method: get
  from: /example-project/src/ExampleProject/bin/${{config}}/net6.0/linux-x64
  to: /some/local/path/example-project/${{bld_run_id}}
  after: main

jobs:
  main:
  - git clone -b ${{branch}} https://some-url-for-the-repository
  - cd /example-project/src/ExampleProject &amp;&amp; dotnet build -c ${{config}}
</code></pre>
<p>This is the example pipeline called <code>example-project/deploy.yaml</code> that runs on the host machine that initiates both pipelines in parallel and also makes a simple deployment of the release build.</p>
<pre><code class="language-yaml">name: Example project deployment pipeline
version: 2
runs_on: machine

variables:
  branch: master

external:
- pipeline: example-project/sonar.yaml
  variables:
    branch: ${{branch}}

- pipeline: example-project/build.yaml
  variables:
    branch: ${{branch}}

jobs:
  scanner:
  - ext: example-project/scanner.yaml

  build_and_deploy:
  - ext: example-project/build.yaml
  - scp -r /some/local/path/example-project/${{bld_run_id}} user@some-ip:/some/path/to/the/server
</code></pre>
<blockquote>
<p>In the above the scanner pipeline runs parallel to the build and deploy since they are set in 2 different jobs. If everything should be run sequentially then the call to the scanner pipeline could be added to the same job as the other steps.</p>
</blockquote>
<h1 id="graceful-shutdown"><a class="header" href="#graceful-shutdown">Graceful shutdown</a></h1>
<p>Since each run could create and run container as well as issue remote runs to bld servers, the cli handles the SIGINT and SIGTERM signals in order to properly cleanup all of the external components. To be noted that the stop command which stops a pipeline running on a server, can be used for a graceful early shutdown of a pipeline.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pipeline-syntax"><a class="header" href="#pipeline-syntax">Pipeline syntax</a></h1>
<p>Bld pipelines are built with backwards compatibility in mind, meaning that after a bld update existing pipelines will not break even if new functionality is introduced or the pipeline changes alltogether.</p>
<p>This is achived through a version number that is seperate from the release version of bld. When a breaking change is introduced in the pipeline syntax, in order to support new features, a pipeline version bump will happen thus all existing pipelines will execute with the set of features they were designed and will not break. This is done to let the user migrate to a new pipeline syntax at their leasure.</p>
<p>The current pipeline versions are</p>
<ul>
<li><a href="pipelines/./version1.html">Version 1</a></li>
<li><a href="pipelines/./version2.html">Version 2</a> <code>latest</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pipeline-v2-syntax"><a class="header" href="#pipeline-v2-syntax">Pipeline V2 syntax</a></h1>
<p>This page explains the syntax of the version 2 pipeline files with examples.</p>
<h1 id="top-level-statements"><a class="header" href="#top-level-statements">Top level statements</a></h1>
<p>The list of top level sections for a pipeline are:</p>
<ul>
<li><strong>version</strong>: The pipeline syntax version. This helps with backwards compatibility and to target this version pipelines it should always be 2.</li>
<li><strong>name</strong>(optional): A name that will be printed on the execution log</li>
<li><strong>runs_on</strong>: The platform configuration that can either be <code>machine</code> or a set of options for a docker image.</li>
<li><strong>cron</strong>(optional): A text value that should represent a schedule of automatic execution for the pipeline that uses the cron syntax.</li>
<li><strong>dispose</strong>(optional): A boolean value that when set to true will not clean up after a run.
<ul>
<li>For machine runs a temporary directory is created under the <code>.bld/tmp/</code> path with a uuid directory for the run.</li>
<li>For container runs the container itself will not be stopped and removed.</li>
</ul>
</li>
<li><strong>variables</strong>(optional): A set of variables that can be used to dynamically replace sections of various other options in the pipeline file.</li>
<li><strong>environment</strong>(optional): A set of environment variables that will be set when executing a step command or can dynamically replace sections of various other options in the pipeline file.</li>
<li><strong>artifacts</strong>(optional): An array that can configure operations for sending or fetching artifacts from a <code>container</code>.</li>
<li><strong>external</strong>(optional): An array that can configure execution of other pipelines either in the same Bld instance or to a target server.</li>
<li><strong>jobs</strong>: A set of command steps to execute, pipelines to call or invoke in a server. Jobs are executed in parallel.</li>
</ul>
<p>Let's take for example the below pipeline, with the file name example.yaml, that needs to run on the current <code>machine</code> and list all files in a directory</p>
<pre><code class="language-yaml">name: Example pipeline 1
runs_on: machine
working_dir: /home/user/target_directory
version: 2

jobs:
  main:
  - ls /home/user/target_directory
</code></pre>
<h1 id="version"><a class="header" href="#version">Version</a></h1>
<p>The <code>version</code> field is a mandatory field for the pipeline and for this part of the documentation it should always be 2 for the below features to be supported.</p>
<pre><code class="language-yaml">version: 2
</code></pre>
<h1 id="name"><a class="header" href="#name">Name</a></h1>
<p>The <code>name</code> field is optional and simply will print out the defined value at the start of the pipeline's execution.</p>
<pre><code class="language-yaml">name: An example pipeline name
</code></pre>
<blockquote>
<p>Note: The name field supports expressions so a variable, an environment variable or a built in constant can be used.</p>
</blockquote>
<h1 id="runs_on"><a class="header" href="#runs_on">Runs_on</a></h1>
<p>The <code>runs_on</code> field in the pipeline defines the platform of execution. This can either be the host <code>machine</code> or a container and as shown above to invoke a pipeline on the machine you simply specify the value machine.</p>
<pre><code class="language-yaml">runs_on: machine
</code></pre>
<p>For container there are mutliple options that can either simply create a container with an existing image by specifing it by name.</p>
<pre><code class="language-yaml">runs_on: ubuntu
</code></pre>
<p>But it can also be configured to pull the desired image based on its name and it supports the use of a tag.</p>
<pre><code class="language-yaml">runs_on:
  image: ubuntu
  pull: true
</code></pre>
<pre><code class="language-yaml">runs_on:
  image: ubuntu:20.04
  pull: true
</code></pre>
<p>Finally the runs_on field can be configured to build a dockerfile and create the necessary image, and provide it with a name and a tag.</p>
<pre><code>runs_on:
  dockerfile: /path/to/dockerfile
  name: custom-image
  tag: latest
</code></pre>
<blockquote>
<p>Note: The runs_on field supports expressions so a variable, an environment variable or a built in constant can be used.</p>
</blockquote>
<h1 id="cron"><a class="header" href="#cron">Cron</a></h1>
<p>The <code>cron</code> field is optional and can configure the execution of a pipeline in a schedule that is defined using the cron syntax. <em>This field is only supported for server runs and doesn't affect local runs</em>.</p>
<p>An example use case it would be to execute a pipeline every 10 seconds</p>
<pre><code class="language-yaml">cron: 10 * * * * * *
</code></pre>
<blockquote>
<p>Note: This field will set up a scheduled execution with the default values for variables and environment variables. If a more parameterized scheduled job is required please visit the <code>cron</code> cli subcommand.</p>
</blockquote>
<h1 id="dispose"><a class="header" href="#dispose">Dispose</a></h1>
<p>The dispose field is optional and when set to true, it wont clean up after a pipeline run.</p>
<p>Specifically</p>
<ul>
<li>For machine runs a temporary directory is created under the <code>.bld/tmp/</code> path with a uuid directory for the run.</li>
<li>For container runs the container itself will not be stopped and removed.</li>
</ul>
<h1 id="variables"><a class="header" href="#variables">Variables</a></h1>
<p>The variables section is a hashmap where the key is the variable name and the value is its default value. The value of a variable can be modified by the user when running the pipeline.</p>
<p>Based on the first example, that was rather specific, we could enhance our pipeline with a variable to either list the content of the target_directory or another one specified when using the <code>run</code> subcommand. Below is a configured pipeline with a variable</p>
<pre><code class="language-yaml">name: Example pipeline with variables 1
runs_on: machine
version: 2

variables:
  directory: /home/user/target_directory

jobs:
  main:
  - ls ${{directory}}
</code></pre>
<p>Here we see the syntax for using a Bld variable, configuring its name and default value. It can be used with the format <code>${{directory}}</code> with the target variable name inside the curly braces. You can run the pipeline normally and leave the value as is or you can use the <code>-v</code> or <code>--variable</code> option of the <code>run</code> subcommand</p>
<pre><code class="language-bash">$ bld run -p example.yaml -v directory=/home/kvl/another_directory
</code></pre>
<p>We can define multiple variables</p>
<pre><code class="language-yaml">name: Example pipeline with variables 2
runs_on: machine
version: 2

variables:
  first_directory: /home/user/target_directory
  second_directory: /home/user/another_directory
  third_directory: /home/user/yet_another_directory

jobs:
  main:
  - ls ${{first_directory}}
  - ls ${{second_directory}}
  - ls ${{third_directory}}
</code></pre>
<p>And set new values using the cli</p>
<pre><code class="language-bash">$ bld run -p example.yaml -v first_directory=some_path -v second_directory=some_other_path -v third_directory=some_yet_another_path
</code></pre>
<blockquote>
<p>Note: The variable fields support expressions so a variable, an environment variable or a built in constant can be used as a variable's default value.</p>
</blockquote>
<h1 id="environment-variables"><a class="header" href="#environment-variables">Environment variables</a></h1>
<p>Same with the variables section, the environment variables section is a hashmap where the key is the variable name and the value is its default value. The value of an environment variable can be modified the user when running the pipeline.</p>
<p>Just like with variables, they can be used with the same format as a variable or use the syntax $ syntax.</p>
<pre><code class="language-yaml">name: Example pipeline with environment variables 1
runs_on: machine
version: 2

environment:
  first_directory: /home/user/target_directory
  second_directory: /home/user/another_directory

jobs:
  main:
  - name: List content of all directories
    exec:
    - ls ${{first_directory}}
    - ls $second_directory
</code></pre>
<p>And specify a different value using the <code>-e</code> or <code>--environment</code> of the <code>run</code> subcommand</p>
<pre><code class="language-bash">$ bld run -p example.yaml -e first_directory=some_path -e second_directory=some_other_path
</code></pre>
<blockquote>
<p>Note: The environment variable fields support expressions so a variable, an environment variable or a built in constant can be used as a environment variable's default value.</p>
</blockquote>
<h1 id="keywords"><a class="header" href="#keywords">Keywords</a></h1>
<p>This isn't related to any field available to the pipeline syntax but more regarding the expressions. Bld has some built in keywords for specific information about a run, those are</p>
<ul>
<li><strong>bld_root_dir</strong>: This is the path to the .bld directory of the project.</li>
<li><strong>bld_run_id</strong>: This is the unique uuid for the pipeline run.</li>
<li><strong>bld_start_time</strong>: The start time of the pipeline run.</li>
</ul>
<blockquote>
<p>All of the above can be used with the expression syntax similar to a variable and environment variable e.g. ${{bld_root_dir}}</p>
</blockquote>
<h1 id="artifacts"><a class="header" href="#artifacts">Artifacts</a></h1>
<p>This section can be used to send or fetch files to or from a container created by a run. For example let say we create a pipeline that will create a file in an <code>ubuntu</code> container and then fetch it on the current machine.</p>
<pre><code class="language-yaml">name: Example pipeline for artifacts
runs_on: ubuntu
version: 2

artifacts:
- method: get
  from: /sample_file
  to: /home/user/some_directory
  after: main

jobs:
  main:
  - echo 'hello world' &gt; sample_file

</code></pre>
<p>The artifacts section supports methods <code>get</code> to retrieve files and <code>push</code> to send files to the container. The <code>after</code> field can specify a step instead of a job or it can be omitted in order for the operation to execute before any job or step.</p>
<pre><code class="language-yaml">name: Example pipeline for artifacts
runs_on: ubuntu
version: 2

artifacts:
- method: get
  from: /sample_file
  to: /home/user/some_directory
  after: Echo step

jobs:
  main:
  - name: Echo step
    exec:
    - echo 'hello world' &gt; sample_file
  - name: Another echo step
    exec:
    - echo 'hello again'
</code></pre>
<blockquote>
<p>Note: The artifacts section support expressions so a variable, an environment variable or a built in constant can be used in the <code>from</code>, <code>to</code> and <code>after</code> fields.</p>
</blockquote>
<h1 id="external"><a class="header" href="#external">External</a></h1>
<p>The <code>external</code> section can used to declare information about another pipeline (either local or on a remote server) and be invoked by jobs.</p>
<p>Lets see all 3 ways that an external pipeline can be called. The first way is to simply call it in the exec part of a step.</p>
<pre><code class="language-yaml">runs_on: ubuntu
version: 2

jobs:
  main:
  - ext: child.yaml
</code></pre>
<p>The second way is to define a new entry to the external section for the pipeline. This will pick up any values for variables and environment variables are desired for the invokation.</p>
<pre><code class="language-yaml">runs_on: ubuntu
version: 2

external:
- pipeline: child.yaml
  variables:
    some-variable: an example value

jobs:
  main:
  - ext: child.yaml
</code></pre>
<p>The third way is to use a name in the external entries which can even have the same pipelines but with different declarations.</p>
<pre><code class="language-yaml">runs_on: ubuntu
version: 2

variables:
  some-variable: an examples value

external:
- name: Call child.yaml with a variable
  pipeline: child.yaml
  variables:
    some-variable: ${{some-variable}}

- name: Call child.yaml on a server
  pipeline: child.yaml
  server: demo_server
  variables:
    some-variable: an example value

- name: Call child-2.yaml on a server
  pipeline: child-2.yaml
  server: demo_server

jobs:
  main:
  - ext: Call child.yaml with a variable
  - ext: Call child.yaml on a server
  - ext: Call child-2.yaml on a server
</code></pre>
<p>In the external section you can define a server in order to invoke the child pipeline to a Bld server. For example let see the below example that invokes a pipeline to a server called <code>demo</code>.</p>
<pre><code class="language-yaml">pipeline: Parent pipeline
runs_on: ubuntu
version: 2

external:
- pipeline: child.yaml
  server: demo

jobs:
  main:
  - name: Do execute child
    exec:
    - ext: child.yaml
</code></pre>
<p>The <code>external</code> section can be configured to pass both variables and environment variables to the target pipeline. See the below example for configuring them</p>
<pre><code class="language-yaml">external:
- name: Execute child pipeline
  pipeline: child.yaml
  variables:
  - variable1: hello
  - variable2: ${{some_variable}}
  environment:
  - env1: hello world
</code></pre>
<blockquote>
<p>Note: The external section support expressions so a variable, an environment variable or a built in constant can be used in the <code>name</code>, <code>server</code>, <code>pipeline</code>, <code>variables</code> and <code>environment</code> fields.</p>
</blockquote>
<h1 id="jobs"><a class="header" href="#jobs">Jobs</a></h1>
<p>The <code>jobs</code> section describes a set of parallel commands to be executed or external pipelines to be invoked. All jobs contain a number of steps with steps having mutliple representation for the level of complexity they want to achieve.</p>
<p>Let's take a look at an example where a pipeline will execute a single job with multiple steps that print a message to stdout.</p>
<pre><code class="language-yaml">name: Example pipeline
runs_on: machine
version: 2

jobs:
  main:
  - echo 'hello world'
  - echo 'hello again'
  - echo 'goodbye'
</code></pre>
<p>If you've read the previous section for the external pipelines, you will already know that by using the <code>ext:</code> on one of a job's step, the action taken is to invoke that pipeline, based on the external configuration (if no configuration is present the pipeline is simply run locally).</p>
<pre><code class="language-yaml">name: Example pipeline
runs_on: machine
version: 2

jobs:
  main:
  - ext: example-pipeline-1.yaml
  - ext: example-pipeline-2.yaml
  - echo 'hello'
</code></pre>
<p>if a step requires more refined operations such as executing many actions you can define a <code>name</code> and an <code>exec</code> list.</p>
<pre><code class="language-yaml">name: Example pipeline for multiple steps
runs_on: machine
version: 2

jobs:
  main:
  - name: List the content of directories
    exec:
    - ls ./some_directory
    - ls ./some_other_directory
    - ls ./yet_another_directory

  - name: Create a sample file
    exec:
    - echo 'hello world' &gt; sample_file

  - name: Curl IP address
    exec:
    - curl ifconfig.me
</code></pre>
<p>A named step can also have <code>ext</code> entries as shown below</p>
<pre><code class="language-yaml">name: Example pipeline for calling another pipeline
runs_on: machine
version: 2

jobs:
  main:
  - name: Call another pipeline and list a directory
    exec:
    - ext: example-1.yaml
    - ls ./some_directory
</code></pre>
<p>You can use the <code>working_dir</code> option to change the target directory for a specific step as show below</p>
<pre><code class="language-yaml">name: Example pipeline
runs_on: ubuntu
version: 2

jobs:
  main:
  - name: First step
    working_dir: /some/working/directory
    exec:
    - ls ./subdirectory
    - rm ./subdirectory/file

  - name: Second step
    working_dir: /another/working/directory
    exec:
    - ls ./some-other-dir/
</code></pre>
<p>Remember that a named step can be used from an artifacts section to transfer data from or to a container.</p>
<blockquote>
<p>Note: The jobs section support expressions so a variable, an environment variable or a built in constant can be used in all forms of a step and it's fields.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pipeline-v1-syntax"><a class="header" href="#pipeline-v1-syntax">Pipeline V1 syntax</a></h1>
<p>This page is dedicated in explaining the syntax of the version 1 pipeline files with examples.</p>
<h1 id="top-level-statements-1"><a class="header" href="#top-level-statements-1">Top level statements</a></h1>
<p>The list of top level sections for a pipeline are:</p>
<ul>
<li><strong>name</strong>(optional): A name that will be printed on the execution log.</li>
<li><strong>runs_on</strong>: The target run platform that can either be <code>machine</code> or the name of a docker image.</li>
<li><strong>version</strong>: The pipeline syntax version. This helps with backwards compatibility.</li>
<li><strong>dispose</strong>(optional): A boolean value that when set to true will not clean up after a run.
<ul>
<li>For machine runs a temporary directory is created under the <code>.bld/tmp/</code> path with a uuid directory for the run.</li>
<li>For container runs the container itself will not be stopped and removed.</li>
</ul>
</li>
<li><strong>variables</strong>(optional): An array of variables that can be used to dynamically replace sections of a step command.</li>
<li><strong>environment</strong>(optional): An array of environment variables that will be set when executing a step command.</li>
<li><strong>artifacts</strong>(optional): An array that can configure operations for sending or fetching artifacts from a <code>container</code>.</li>
<li><strong>external</strong>(optional): An array that can configure execution of other pipelines either in the same Bld instance or to a target server.</li>
<li><strong>steps</strong>: An array of command to execute, pipelines to call or invoke in a server.</li>
</ul>
<p>Let's take for example the below pipeline, with the file name example.yaml, that needs to run on the current <code>machine</code> and list all files in a directory</p>
<pre><code class="language-yaml">name: Example pipeline 1
runs_on: machine
working_dir: /home/user/target_directory
version: 1

steps:
- name: List all content of target_directory
  working_dir: /home/user/target_directory
  exec:
  - ls
</code></pre>
<h1 id="variables-1"><a class="header" href="#variables-1">Variables</a></h1>
<p>The variables section is a hashmap where the key is the variable name and the value is its default value. The value of a variable can be modified the user when running the pipeline.</p>
<p>Based on the previous example, that was rather specific, we could enhance our pipeline with a variable to either list the content of the target_directory or another one specified when using the <code>run</code> subcommand. Below is a configured pipeline with a variable</p>
<pre><code class="language-yaml">name: Example pipeline with variables 1
runs_on: machine
version: 1

variables:
  directory: /home/user/target_directory

steps:
- name: List all content of target_directory
  working_dir: bld:var:directory
  exec:
  - ls
</code></pre>
<p>Here we see the syntax for using a Bld variable, configuring its name and default value. It can be used with the <code>bld:var:</code> prefix and using the name <code>directory</code> for the variable name. You can run the pipeline normally and leave the value as is or you can use the <code>-v</code> or <code>--variable</code> option of the <code>run</code> subcommand</p>
<pre><code class="language-bash">$ bld run -p example.yaml -v directory=/home/kvl/another_directory
</code></pre>
<p>We can define multiple variables</p>
<pre><code class="language-yaml">name: Example pipeline with variables 2
runs_on: machine
version: 1

variables:
  first_directory: /home/user/target_directory
  second_directory: /home/user/another_directory
  third_directory: /home/user/yet_another_directory

steps:
- name: List content of all directories
  exec:
  - ls bld:var:first_directory
  - ls bld:var:second_directory
  - ls bld:var:third_directory
</code></pre>
<p>And set new values using the cli</p>
<pre><code class="language-bash">$ bld run -p example.yaml -v first_directory=some_path -v second_directory=some_other_path -v third_directory=some_yet_another_path
</code></pre>
<h1 id="environment-variables-1"><a class="header" href="#environment-variables-1">Environment variables</a></h1>
<p>Same with the variables section, the environment variables section is a hashmap where the key is the variable name and the value is its default value. The value of an environment variable can be modified the user when running the pipeline.</p>
<p>Just like with variables, they can used with the <code>bld:env:</code> prefix or use the syntax $ syntax.</p>
<pre><code class="language-yaml">name: Example pipeline with environment variables 1
runs_on: machine
version: 1

environment:
  first_directory: /home/user/target_directory
  second_directory: /home/user/another_directory

steps:
- name: List content of all directories
  exec:
  - ls bld:env:first_directory
  - ls $second_directory
</code></pre>
<p>And specify a different value using the <code>-e</code> or <code>--environment</code> of the <code>run</code> subcommand</p>
<pre><code class="language-bash">$ bld run -p example.yaml -e first_directory=some_path -e second_directory=some_other_path
</code></pre>
<h1 id="artifacts-1"><a class="header" href="#artifacts-1">Artifacts</a></h1>
<p>This section can be used to send or fetch files to or from a container created by a run. For example let say we create a pipeline that will create a file in an <code>ubuntu</code> container and then fetch it on the current machine.</p>
<pre><code class="language-yaml">name: Example pipeline for artifacts
runs_on: ubuntu
version: 1

steps:
- name: Create a sample file
  exec:
  - echo 'hello world' &gt; sample_file

artifacts:
- method: get
  from: /sample_file
  to: /home/user/some_directory
  after: Create a sample file
</code></pre>
<p>The artifacts section supports methods <code>get</code> to retrieve files and <code>push</code> to send files to the container. Additionally the <code>after</code> section can be omitted in order for the operation to execute before any step.</p>
<h1 id="external-1"><a class="header" href="#external-1">External</a></h1>
<p>The <code>external</code> section can used to declare information about another pipeline (either local or on a remote server) and be invoked by steps section. Let's see an example with a parent pipeline called <code>parent.yaml</code> that needs to execute a child pipeline called <code>child.yaml</code>.</p>
<pre><code class="language-yaml">pipeline: Parent pipeline
runs_on: ubuntu
version: 1

external:
- pipeline: child.yaml

steps:
- name: Do execute child
  exec:
  - ext: child.yaml
</code></pre>
<p>The above is the simplest form of executing another pipeline locally, but a server option can be provided if the run of the child pipeline needs to be done in another machine. Lets change the above example in order to invoke the child pipeline to a Bld server called <code>demo</code>.</p>
<pre><code class="language-yaml">pipeline: Parent pipeline
runs_on: ubuntu
version: 1

external:
- pipeline: child.yaml
  server: demo

steps:
- name: Do execute child
  exec:
  - ext: child.yaml
</code></pre>
<p>The <code>external</code> section can be configured to pass both variables and environment variables to the target pipeline. See the below example for configuring them</p>
<pre><code class="language-yaml">external:
- name: Execute child pipeline
  pipeline: child.yaml
  variables:
  - variable1: hello
  - variable2: world
  environment:
  - env1: hello world
</code></pre>
<p>Lets see all 3 ways that an external pipeline can be called. The first way is to simply call it in the exec part of a step.</p>
<pre><code class="language-yaml">runs_on: ubuntu
version: 1

steps:
- exec:
  - ext: child.yaml
</code></pre>
<p>The second way is to define a new entry to the external section for the pipeline. This will pick up any values for variables and environment variables are desired for the invokation.</p>
<pre><code class="language-yaml">runs_on: ubuntu
version: 1

external:
- pipeline: child.yaml
  variables:
    some-variable: an example value

steps:
- exec:
  - ext: child.yaml
</code></pre>
<p>The third way is to use a name in the external entries in order to have different declarations for the same pipeline.</p>
<pre><code class="language-yaml">runs_on: ubuntu
version: 1

external:
- name: Call child.yaml with a variable
  pipeline: child.yaml
  variables:
    some-variable: an example value

- name: Call child.yaml on a server
  pipeline: child.yaml
  server: demo_server
  variables:
    some-variable: an example value

steps:
- exec:
  - ext: Call child.yaml with a variable
  - ext: Call child.yaml on a server
</code></pre>
<h1 id="steps"><a class="header" href="#steps">Steps</a></h1>
<p>The <code>steps</code> section describes a set of commands to be executed or external pipelines to be invoked. Lets look at an example where there are multiple steps in a pipeline for listing contents of a directory, creating a sample file and using curl to see the IP address of the machine.</p>
<pre><code class="language-yaml">name: Example pipeline for multiple steps
runs_on: machine
version: 1

steps:
- name: List the content of directories
  exec:
  - ls ./some_directory
  - ls ./some_other_directory
  - ls ./yet_another_directory

- name: Create a sample file
  exec:
  - echo 'hello world' &gt; sample_file

- name: Curl IP address
  exec:
  - curl ifconfig.me
</code></pre>
<p>Let's consider now that the above pipeline was called <code>example-1.yaml</code> and we wanted all of its steps to be part of another pipeline called <code>example-2.yaml</code>, we could call the pipeline as shown below.</p>
<pre><code class="language-yaml">name: Example pipeline for calling another pipeline
runs_on: machine
version: 1

steps:
- name: Call another pipeline and list a directory
  exec:
  - ext: example-1.yaml
  - ls ./some_directory
</code></pre>
<p>You can use the <code>working_dir</code> option to change the target directory for a specific step as show below</p>
<pre><code class="language-yaml">name: Example pipeline
runs_on: ubuntu
version: 1

steps:
- name: First step
  working_dir: /some/working/directory
  exec:
  - ls ./subdirectory
  - rm ./subdirectory/file

- name: Second step
  working_dir: /another/working/directory
  exec:
  - ls ./some-other-dir/
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-configure-bld"><a class="header" href="#how-to-configure-bld">How to configure bld</a></h1>
<p>You can edit the <code>config.yaml</code> file inside a <code>.bld</code> directory in order to configure both local options and add new target bld servers.</p>
<h1 id="local-configuration"><a class="header" href="#local-configuration">Local configuration</a></h1>
<p>The <code>local</code> section of the configuration has the below options available
ability mode.</p>
<ul>
<li>
<p><strong>docker_url</strong>: The url with which a connection will be established to the docker engine API.</p>
</li>
<li>
<p><strong>server</strong>: The start of the server section with the below options</p>
<ul>
<li><strong>host</strong>: The host that the server will be exposed to.</li>
<li><strong>port</strong>: The port that the server will be exposed to.</li>
<li><strong>tls</strong>: The start of the tls section with the below options
<ul>
<li><strong>cert_chain</strong>: The path to a certificate file.</li>
<li><strong>private_key</strong>: The path to the private key for the above certificate.</li>
</ul>
</li>
<li><strong>pipelines</strong>: A path to a directory in which the server will store registered pipelines.</li>
<li><strong>auth</strong>: The authentication section for the server.
<ul>
<li><strong>method</strong>: A text option that for the current release only accepts the value oidc.</li>
<li><strong>issuer_url</strong>: The issuer url for the authorization provider.</li>
<li><strong>redirect_url</strong>: The redirect url of the bld server.</li>
<li><strong>client_id</strong>: The client id configured in the oidc provider for the bld server.</li>
<li><strong>client_secret</strong>: The client secret for the bld server.</li>
<li><strong>scopes</strong>: An array of scopes provided when logging in.</li>
<li><strong>user_property</strong>: The property that a user will be associated with. Accepts the values name or email.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>supervisor</strong>: The start of the supervisor section</p>
<ul>
<li><strong>host</strong>: The host that the supervisor will be exposed to.</li>
<li><strong>port</strong>: The port that the supervisor will be exposed to.</li>
<li><strong>tls</strong>: The start of the tls section with the below options
<ul>
<li><strong>cert_chain</strong>: The path to a certificate file.</li>
<li><strong>private_key</strong>: The path to the private key of the above certificate.</li>
</ul>
</li>
<li><strong>workers</strong>: A number that indicates how many worker processes can the supervisor spawn. This will be the maximum number of active pipeline runs on a server, with all other being queued.</li>
</ul>
</li>
<li>
<p><strong>logs</strong>: A path to a directory where the logs for each server run will be stored.</p>
</li>
<li>
<p><strong>db</strong>: A path to a directory where the database file for the server will be created.</p>
</li>
<li>
<p><strong>editor</strong>: The name or path to your editor of choice for editing a pipeline through the bld cli.</p>
</li>
</ul>
<h1 id="remote-configuration"><a class="header" href="#remote-configuration">Remote configuration</a></h1>
<p>The <code>remote</code> section of the config file is an array of servers that can be targeted. The available options are below.</p>
<ul>
<li><strong>server</strong>: The name used to target this entry.</li>
<li><strong>host</strong>: The host address of the server.</li>
<li><strong>port</strong>: The port of the server.</li>
<li><strong>tls</strong>: A boolean indicating to use secure protocols when connecting to the server.</li>
</ul>
<h1 id="putting-it-all-together"><a class="header" href="#putting-it-all-together">Putting it all together</a></h1>
<p>Below is an example configuration with all of the above options</p>
<pre><code class="language-yaml">local:
  server:
     host: localhost
     port: 6080
     tls:
        cert_chain: path/to/server_certificate.crt
        private_key: path/to/server_private.key
     auth:
        method: oidc
        issuer_url: https://some_issuer_url
        redirect_url: https://localhost:6080/authRedirect
        client_id: some_client_id
        client_secret: some_client_secret
        scopes: [&quot;scope1&quot;, &quot;scope2&quot;]
        user_property: email
     pipelines: .bld/server_pipelines
  supervisor:
     host: localhost
     port: 7080
     tls:
        cert_chain: path/to/supervisor_certificate.crt
        private_key: path/to/supervisor_private.key
     workers: 50
  logs: .bld/logs
  db: .bld/db
  docker-url: tcp://127.0.0.1:2376
  editor: vim

remote:
- server: local_1
  host: 127.0.0.1
  port: 6080
  tls: true
- server: local_2
  host: 127.0.0.1
  port: 8080
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="server-mode"><a class="header" href="#server-mode">Server mode</a></h1>
<p>Bld can run in server mode in order to run, push, pull, list pipelines and more. This section of the book goes into more detail on some of features of a server.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-start-a-server"><a class="header" href="#how-to-start-a-server">How to start a server</a></h1>
<p>Bld has configuration options for running in server mode. In a brand new project you can run</p>
<pre><code class="language-bash">$ bld init -s
</code></pre>
<p>To initialize a .bld directory with a <code>config.yaml</code> that has some default values. Additionally, you can use the <code>config</code> sub-command in order to print the entire configuration of your project.</p>
<p>Once the project is initialized, you can use the <code>server</code> sub-command to start bld in server mode.</p>
<pre><code class="language-bash">$ bld server
$ bld server --verbose # run with verbosity and see debug logs
</code></pre>
<h1 id="running-a-server-pipeline"><a class="header" href="#running-a-server-pipeline">Running a server pipeline</a></h1>
<p>For this section let's say that you have deployed a bld server on a VM or container and want to run a pipeline on it. To do this you need first to target that server in your project's <code>config.yaml</code> file</p>
<pre><code class="language-yaml">local:
  docker_url: tcp://127.0.0.1:2376

remote:
- server: example_server
  host: 127.0.0.1
  port: 6080
</code></pre>
<p>In the above example, we have the <code>example_server</code> in our remote config section, which is available at the defined host and port.</p>
<p>A Bld server generates and connect to a sqlite database in order to keep track of pipelines, runs and containers. This means that in order to run a pipeline on it, you need first to register it. To do this you can use the <code>push</code> sub-command. For example let's say that in a local project you have the <code>sample.yaml</code> pipeline. Execute the below to register it to the <code>example_server</code></p>
<pre><code class="language-bash">$ bld push -s example_server -p sample.yaml
</code></pre>
<p>Once pushed you can use helper sub-commands like</p>
<ul>
<li><code>list</code> to see all registered pipelines</li>
<li><code>cat</code> to see the content of a pipeline on the server</li>
<li><code>pull</code> to download a pipeline from a server</li>
<li><code>rm</code> to remove a pipeline from a server</li>
</ul>
<blockquote>
<p>For more details on each action, see the Command line interface page.</p>
</blockquote>
<p>Finnaly, to run the pipeline use the <code>run</code> sub-command and specify the target server</p>
<pre><code class="language-bash">$ bld run -s example_server -p sample.yaml
</code></pre>
<p>This will start the execution on the server side and keep a web socket connection in order to see in real time the output of the pipeline. Use the <code>--detach</code> flag to detach from the run. This will send a request to start the run and return immediately.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="authorization"><a class="header" href="#authorization">Authorization</a></h1>
<p>Server mode does not have it's own authorization method but it uses external services. The only current method is using an existing oidc provider with an example below.</p>
<h2 id="configuration-of-server-to-validate-user-using-googles-oidc"><a class="header" href="#configuration-of-server-to-validate-user-using-googles-oidc">Configuration of server to validate user using google's oidc</a></h2>
<p>The below example assumes that google authorization has been setup.</p>
<pre><code class="language-yaml">local:
  server:
    host: localhost
    port: 6080
    auth:
      method: oidc
      issuer_url: https://accounts.google.com
      redirect_url: http://localhost:6080/auth/redirect
      client_id: __the client id__
      client_secret: __the client secret__
      scopes: [&quot;openid&quot;, &quot;profile&quot;, &quot;email&quot;]
      user_property: name
  docker_url: tcp://127.0.0.1:2376
</code></pre>
<blockquote>
<p>Note: The <code>user_property</code> field will be used as the identification name for the user for various logs in the server such as run history etc. The only available values are name or email and these are retrieved from the user info url discovered from the oidc provider.</p>
</blockquote>
<h2 id="configuration-of-a-server-from-a-clients-configyaml"><a class="header" href="#configuration-of-a-server-from-a-clients-configyaml">Configuration of a server from a client's config.yaml</a></h2>
<p>This will send a request to the provided validation url in order to fetch the user info.</p>
<pre><code class="language-yaml">local:
  docker_url: tcp://127.0.0.1:2376
remote:
- server: local_server
  host: localhost
  port: 6080
</code></pre>
<h2 id="login-process"><a class="header" href="#login-process">Login process</a></h2>
<p>Use the <code>login</code> subcommand from the client this will connect to the server using a websocket that in turn will start the login operation.</p>
<pre><code class="language-bash">$ bld login -s local_server
</code></pre>
<p>Once the login process starts, a url will be sent to the client and be opened automatically in a browser instance that will point to google's login page (If opening the brower fails, the url will be printed to stdout for the user to navigate m. Once the user is authenticated, the server will receive the tokens send them to the client throught the open web socket and then the login process will finish.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tls"><a class="header" href="#tls">TLS</a></h1>
<p>Server mode can be configured to use a certificate for https and wss connections. For most cases having the server behind a battle tested reverse proxy would be best.</p>
<p>To configure the certificate see the below example</p>
<pre><code class="language-yaml">local:
    server:
        host: 127.0.0.1
        port: 6080
        tls:
            cert_chain: /path/to/server/certificate
            private_key: /path/to/server/private-key
    supervisor:
        host: 127.0.0.1
        port: 7080
        tls:
            cert_chain: /path/to/supervisor/certificate
            private_key: /path/to/supervisor/private-key

</code></pre>
<p>The certificate should be of type PEM. Setting the tls option for the supervisor means that all communications between the server and the supervisor will be done using https and wss.</p>
<p>Connecting to a server with enabled tls, the local configuration should have the option of tls set to true, as seen in the below example.</p>
<pre><code class="language-yaml">local:
    docker_url: tcp://127.0.0.1:2376
remote:
    - server: local_srv
      host: 127.0.0.1
      port: 6080
      tls: true
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-line-interface"><a class="header" href="#command-line-interface">Command line interface</a></h1>
<p>This section lists all available subcommands for the bld binary.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cat"><a class="header" href="#cat">Cat</a></h1>
<p>The <code>cat</code> sub-command will print the content of a pipeline on a Bld server.</p>
<p><strong>options</strong></p>
<ul>
<li>--verbose              Sets the level of verbosity</li>
<li>-p, --pipeline <PIPELINE>  The name of the pipeline to print</li>
<li>-s, --server <SERVER>      The name of the server to print the pipeline from</li>
<li>-h, --help                 Print help</li>
<li>-V, --version              Print version</li>
</ul>
<p><strong>usage</strong></p>
<pre><code class="language-bash">$ bld inspect -s local_server -p example_pipeline.yaml
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="check"><a class="header" href="#check">Check</a></h1>
<p>The <code>check</code> sub-command will validate a pipeline file for errors.</p>
<p><strong>options</strong></p>
<ul>
<li>--verbose              Sets the level of verbosity</li>
<li>-p, --pipeline <PIPELINE>  Path to pipeline script [default: default.yaml]</li>
<li>-s, --server <SERVER>      The name of the server to check the pipeline from</li>
</ul>
<p><strong>usage</strong></p>
<pre><code class="language-bash">$ bld check
$ bld check -s local_server -p example_pipeline.yaml
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="config"><a class="header" href="#config">Config</a></h1>
<p>The <code>config</code> sub-command lists all of Bld's configuration. This will also print configuration options that you might not have set but bld will assign a default value to.</p>
<p><strong>options</strong></p>
<ul>
<li>-e, --edit     Edit the config file</li>
<li>-h, --help     Print help</li>
<li>-V, --version  Print version</li>
</ul>
<p><strong>usage</strong></p>
<pre><code class="language-bash">$ bld config
$ bld config -e # to edit the config file
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cron-1"><a class="header" href="#cron-1">Cron</a></h1>
<p>The <code>cron</code> subcommand provides functionality from manipulating cron jobs in a server.</p>
<p><strong>commands</strong></p>
<ul>
<li>cat     Print detailed information for a registered cron job in a server</li>
<li>add     Adds a cron job to a server</li>
<li>ls      Lists all registered cron jobs in a server</li>
<li>update  Updates a cron job to a server</li>
<li>rm      Removes a registered cron job from a server</li>
<li>help    Print this message or the help of the given subcommand(s)</li>
</ul>
<p><strong>options</strong></p>
<ul>
<li>-h, --help     Print help</li>
<li>-V, --version  Print version</li>
</ul>
<h2 id="cron-cat"><a class="header" href="#cron-cat">Cron cat</a></h2>
<p>The <code>cron cat</code> subcommand prints detailed information for a registered cron job in a server.</p>
<p><strong>options</strong></p>
<ul>
<li>--verbose          Sets the level of verbosity</li>
<li>-s, --server <SERVER>  The name of the server to fetch the cron job from</li>
<li>-i, --id <ID>          The id of the target cron job</li>
<li>-h, --help             Print help</li>
<li>-V, --version          Print version</li>
</ul>
<p><strong>usage</strong></p>
<pre><code class="language-bash">$ bld cron cat -i 5592508f-507c-4224-a7af-1983c2ccb971 -s local
</code></pre>
<h2 id="cron-add"><a class="header" href="#cron-add">Cron add</a></h2>
<p>the <code>cron add</code> subcommand adds a cron job to a server.</p>
<p><strong>options</strong></p>
<ul>
<li>--verbose                    Sets the level of verbosity</li>
<li>-s, --server <SERVER>            The name of the server to upsert the cron job to</li>
<li>-p, --pipeline <PIPELINE>        The name of the target pipeline</li>
<li>-S, --schedule <SCHEDULE>        The new schedule for the cron job</li>
<li>-v, --variable <VARIABLES>       Define value for a variable. Can be used multiple times</li>
<li>-e, --environment <ENVIRONMENT>  Define value for an environment variable. Can be used multiple times</li>
<li>-h, --help                       Print help</li>
<li>-V, --version                    Print version</li>
</ul>
<p><strong>usage</strong></p>
<pre><code class="language-bash">$ bld cron add -s local -p sample-pipeline.yaml -S '10 * * * * * *' -v var1=hello -v var2=world -e env1='hello world'
</code></pre>
<h2 id="cron-ls"><a class="header" href="#cron-ls">Cron ls</a></h2>
<p>The <code>cron ls</code> subcommand lists all registered cron jobs in a server.</p>
<p><strong>options</strong></p>
<ul>
<li>--verbose               Sets the level of verbosity</li>
<li>-s, --server <SERVER>       The name of the server to list the cron jobs from</li>
<li>-i, --id <ID>               The id of the target cron job</li>
<li>-p, --pipeline <PIPELINE>   The pipeline name for the target cron jobs</li>
<li>-S, --schedule <SCHEDULE>   The schedule for the target cron jobs</li>
<li>-d, --default &lt;IS_DEFAULT&gt;  Fetch only the default cron jobs [possible values: true, false]</li>
<li>-l, --limit <LIMIT>         Limit the results</li>
<li>-h, --help                  Print help</li>
<li>-V, --version               Print version</li>
</ul>
<p><strong>usage</strong></p>
<pre><code class="language-bash">$ bld cron ls -s local
$ bld cron ls -s local -p sample-pipeline.yaml
$ bld cron ls -s local -p sample-pipeline.yaml -l 10
$ bld cron ls -s local -l 10 -d true
</code></pre>
<h2 id="cron-update"><a class="header" href="#cron-update">Cron update</a></h2>
<p>The <code>cron update</code> subcommand updates a cron job to a server.</p>
<p><strong>options</strong></p>
<ul>
<li>--verbose                    Sets the level of verbosity</li>
<li>-s, --server <SERVER>            The name of the server to upsert the cron job to</li>
<li>-i, --id <ID>                    The id of the target cron job</li>
<li>-S, --schedule <SCHEDULE>        The new schedule for the cron job</li>
<li>-v, --variable <VARIABLES>       Define value for a variable. Can be used multiple times</li>
<li>-e, --environment <ENVIRONMENT>  Define value for an environment variable. Can be used multiple times</li>
<li>-h, --help                       Print help</li>
<li>-V, --version                    Print version</li>
</ul>
<p><strong>usage</strong></p>
<pre><code class="language-bash">$ bld cron update -s local -i 5592508f-507c-4224-a7af-1983c2ccb971 -S '10 * * * * * *' -v var1=hello -e env1=world
</code></pre>
<h2 id="cron-rm"><a class="header" href="#cron-rm">Cron rm</a></h2>
<p>The <code>cron rm</code> subcommand removes a registered cron job from a server.</p>
<p><strong>options</strong></p>
<ul>
<li>--verbose           Sets the level of verbosity</li>
<li>-i, --id &lt;CRON_JOB_ID&gt;  The id of the cron job to remove</li>
<li>-s, --server <SERVER>   The name of the server to remove the cron job from</li>
<li>-h, --help              Print help</li>
<li>-V, --version           Print version</li>
</ul>
<p><strong>usage</strong></p>
<pre><code class="language-bash">$ bld cron rm -s local -i 5592508f-507c-4224-a7af-1983c2ccb971
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="help"><a class="header" href="#help">Help</a></h1>
<p>The <code>help</code> sub-command will print the general help message for the Bld command line interface or the appropriate help message for another sub-command.</p>
<p><strong>usage</strong></p>
<pre><code class="language-bash">$ bld help
$ bld help run
$ bld help push
$ bld help stop
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hist"><a class="header" href="#hist">Hist</a></h1>
<p>The <code>hist</code> sub-command will fetch execution history of pipelines on a Bld server.</p>
<p><strong>options</strong></p>
<ul>
<li>--verbose              Sets the level of verbosity</li>
<li>-s, --server <SERVER>      The name of the server to fetch history from</li>
<li>-x, --state <STATE>        Filter the history with state. Possible values are all, initial, queued, running, finished [default: running]</li>
<li>-p, --pipeline <PIPELINE>  Filter the history with state. Possible values are all, initial, queued, running, finished</li>
<li>-l, --limit <LIMIT>        Limit the results [default: 100]</li>
<li>-h, --help                 Print help</li>
<li>-V, --version              Print version</li>
</ul>
<p><strong>usage</strong></p>
<pre><code class="language-bash">$ bld hist -s local_server
$ bld hist -s local_server -x initial
$ bld hist -s local_server -x queued
$ bld hist -s local_server -x running
$ bld hist -s local_server -x finished
$ bld hist -s local_server -x faulted
$ bld hist -s local_server -x all
$ bld hist -s local_server -x running -l 200
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="init"><a class="header" href="#init">Init</a></h1>
<p>The <code>init</code> sub-command will initialize a bld project by creating a new .bld directory.</p>
<p><strong>options</strong></p>
<ul>
<li>--verbose  Sets the level of verbosity</li>
<li>-s, --server   Initialize configuration for a bld server</li>
<li>-h, --help     Print help</li>
<li>-V, --version  Print version</li>
</ul>
<p><strong>usage</strong></p>
<pre><code class="language-bash">$ bld init
$ bld init -s
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="login"><a class="header" href="#login">Login</a></h1>
<p>The <code>login</code> sub-command initiates the authentication process to a bld server.</p>
<p><strong>options</strong></p>
<ul>
<li>--verbose          Sets the level of verbosity</li>
<li>-s, --server <SERVER>  The name of the server to login into</li>
<li>-h, --help             Print help</li>
<li>-V, --version          Print version</li>
</ul>
<p><strong>usage</strong></p>
<pre><code class="language-bash">$ bld login -s local_server
$ Opening a new browser tab to start the login process.
# after authenticating from the browser.
$ Login completed successfully!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ls"><a class="header" href="#ls">Ls</a></h1>
<p>The <code>ls</code> sub-command will list local or server pipelines.</p>
<p><strong>options</strong></p>
<ul>
<li>--verbose          Sets the level of verbosity</li>
<li>-s, --server <SERVER>  The name of the server to list pipelines from</li>
<li>-h, --help             Print help</li>
<li>-V, --version          Print version</li>
</ul>
<p><strong>usage</strong></p>
<pre><code class="language-bash">$ bld ls # To list local pipelines
$ bld ls -s local_server # To list server pipelines
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="monit"><a class="header" href="#monit">Monit</a></h1>
<p>The <code>monit</code> sub-command will connect to a Bld server and monitor the execution of a running pipeline.</p>
<p><strong>options</strong></p>
<ul>
<li>--verbose                    Sets the level of verbosity</li>
<li>-i, --pipeline-id &lt;PIPELINE_ID&gt;  The id of the pipeline to monitor. Takes precedence over pipeline</li>
<li>-p, --pipeline <PIPELINE>        The name of the pipeline of which to monitor the last run</li>
<li>-s, --server <SERVER>            The name of the server to monitor the pipeline from</li>
<li>--last                       Monitor the execution of the last invoked pipeline. Takes precedence over pipeline-id and pipeline</li>
<li>-h, --help                       Print help</li>
<li>-V, --version                    Print version</li>
</ul>
<p><strong>usage</strong></p>
<pre><code class="language-bash">$ bld monit -s local_server -p example_pipeline.yaml
$ bld monit -s local_server -i 8f0159e0-7f5c-4dc6-9b1a-70a219d85450
$ bld monit --last
$ bld monit -s local_server --last
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pull"><a class="header" href="#pull">Pull</a></h1>
<p>The <code>pull</code> sub-command will fetch the content of a pipeline from a Bld server.</p>
<p><strong>options</strong></p>
<ul>
<li>--verbose              Sets the level of verbosity</li>
<li>-p, --pipeline <PIPELINE>  The name of the bld server</li>
<li>-s, --server <SERVER>      The name of the server to pull the pipeline from</li>
<li>--ignore-deps          Do not include other pipeline dependencies</li>
<li>-h, --help                 Print help</li>
<li>-V, --version              Print version</li>
</ul>
<p><strong>usage</strong></p>
<pre><code class="language-bash">$ bld pull -s local_server -p example_pipeline.yaml
$ bld pull -s local_server -p example_pipeline.yaml --ignore-deps
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="push"><a class="header" href="#push">Push</a></h1>
<p>The <code>push</code> sub-command will push new content of a pipeline to a Bld server.</p>
<p><strong>options</strong></p>
<ul>
<li>--verbose              Sets the level of verbosity</li>
<li>-p, --pipeline <PIPELINE>  The name of the pipeline to push</li>
<li>-s, --server <SERVER>      The name of the server to push changes to</li>
<li>--ignore-deps          Don't include other pipeline dependencies</li>
<li>-h, --help                 Print help</li>
<li>-V, --version              Print version</li>
</ul>
<p><strong>usage</strong></p>
<pre><code class="language-bash">$ bld push -s local_server -p example_pipeline.yaml
$ bld push -s local_server -p example_pipeline.yaml --ignore-deps
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rm"><a class="header" href="#rm">Rm</a></h1>
<p>The <code>rm</code> sub-command will remove a registered pipeline from a Bld server.</p>
<p><strong>options</strong></p>
<ul>
<li>--verbose              Sets the level of verbosity</li>
<li>-s, --server <SERVER>      The name of the server to remove from</li>
<li>-p, --pipeline <PIPELINE>  The name of the pipeline</li>
<li>-h, --help                 Print help</li>
<li>-V, --version              Print version</li>
</ul>
<p><strong>usage</strong></p>
<pre><code class="language-bash">$ bld rm -p example_pipeline.yaml
$ bld rm -s local_server -p example_pipeline.yaml
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="run"><a class="header" href="#run">Run</a></h1>
<p>The <code>run</code> sub-command will execute a Bld pipeline either locally or on a server.</p>
<p><strong>options</strong></p>
<ul>
<li>--verbose                    Sets the level of verbosity</li>
<li>-p, --pipeline <PIPELINE>        Path to pipeline script [default: default.yaml]</li>
<li>-s, --server <SERVER>            The name of the server to run the pipeline</li>
<li>--detach                     Detaches from the run execution (for server mode runs)</li>
<li>-v, --variable <VARIABLES>       Define value for a variable. Can be used multiple times</li>
<li>-e, --environment <ENVIRONMENT>  Define value for an environment variable. Can be used multiple times</li>
<li>-h, --help                       Print help</li>
<li>-V, --version                    Print version</li>
</ul>
<p><strong>usage</strong></p>
<pre><code class="language-bash">$ bld run -p example_pipeline.yaml
$ bld run -p example_pipeline.yaml -v variable1=some_value -v variable2=some_value -e env_variable=some_value
$ bld run -s local_server -p example_pipeline.yaml
$ bld run -s local_server -p example_pipeline.yaml -d
$ bld run -s local_server -p example_pipeline.yaml -v variable1=some_value -v variable2=some_value -e env_variable=some_value
$ bld run -s local_server -p example_pipeline.yaml -v variable1=some_value -v variable2=some_value -e env_variable=some_value -d
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="server"><a class="header" href="#server">Server</a></h1>
<p>The <code>server</code> subcommand will start a Bld server instance.</p>
<p><strong>options</strong></p>
<ul>
<li>--verbose      Sets the level of verbosity</li>
<li>-H, --host <HOST>  The server's host address</li>
<li>-P, --port <PORT>  The server's port</li>
<li>-h, --help         Print help</li>
<li>-V, --version      Print version</li>
</ul>
<p><strong>usages</strong></p>
<pre><code class="language-bash">$ bld server
$ bld server -H 127.0.0.1 -P 6080
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="supervisor"><a class="header" href="#supervisor">Supervisor</a></h1>
<p>The <code>supervisor</code> sub-command is used by the Bld server and it's advised to not be used it directly.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="worker"><a class="header" href="#worker">Worker</a></h1>
<p>The <code>worker</code> sub-command will spawn a new run for a pipeline but is used internally by the bld server so it's advised not to be used directly.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="examples"><a class="header" href="#examples">Examples</a></h1>
<p>This section of the book has various examples for building and deploying project using bld pipelines.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-a-dotnet-project"><a class="header" href="#build-a-dotnet-project">Build a dotnet project</a></h1>
<p>This is an example pipeline for building a dotnet project in a container and copying the build artifacts to the host machine.</p>
<pre><code class="language-yaml">name: Example dotnet pipeline
version: 2
runs_on:
  image: mcr.microsoft.com/dotnet/sdk:6.0-focal
  pull: true

variables:
  branch: master
  config: release

artifacts:
- method: get
  from: /example_project/src/ExampleProject/bin/bld:var:CONFIG/net6.0
  to: /some/local/path
  after: main

jobs:
  main:
  - git clone -b ${{branch}} https://some-url-to-the-example-project-repository
  - name: Build project
    working_dir: /example_project
    exec:
    - dotnet build -c ${{config}}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-a-nodejs-project"><a class="header" href="#build-a-nodejs-project">Build a nodejs project</a></h1>
<p>This is an example for building a nodejs project in a container and copying the build artifacts to the host machine.</p>
<pre><code class="language-yaml">name: Example nodejs pipeline
version: 2
runs_on:
  image: node:lts
  pull: true

variables:
  branch: master
  script: build-prod

artifacts:
- method: get
  from: /example_project/path/to/build/files
  to: /some/local/path
  after: main

jobs:
  main:
  - git clone -b ${{branch}} https://some-url-to-the-example-project-repository
  - name: Build project
    working-dir: /example_project
    exec:
    - npm install
    - npm run ${{SCRIPT}}

</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
